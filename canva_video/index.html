<!DOCTYPE html>
<html>
  <head>
    <title>
      canva+video
    </title>
    <meta charset="utf-8">
    <link rel="icon" type="image/x-icon" href="files/images/favicon.ico">
    <meta name="author" content="http://radservebeer.free.fr">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="files/Styles/style.css" type="text/css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="files/Styles/shCore.css">
    <link type="text/css" rel="Stylesheet" href="files/Styles/shThemeRDark.css" id="theme">
    <script type="text/javascript" src="files/Scripts/shCore.js"></script>
    <script type="text/javascript" src="files/Scripts/shBrushCss.js"></script>
    <script type="text/javascript" src="files/Scripts/shBrushJScript.js"></script>
    <script type="text/javascript" src="files/Scripts/shBrushXml.js"></script>
    <script type="text/javascript" src="files/Scripts/shBrushPlain.js"></script>
</head>
  <body>
    <div class="flex-container">
      <div class="item1">
        <img src="files/images/logo.png" width="400" height="150" class="logo" alt="logo">
      </div>
      <div class="item2">
        <div id="contant">
          <div class="method">
           <p>&nbsp;
              Vous avez déjà entendu parler des éléments <code>&lt;video&gt;</code> et <code>&lt;canvas&gt;</code> ,
              mais saviez-vous qu'ils ont été conçus pour être utilisés ensemble ? En fait, les deux éléments sont
              absolument merveilleux lorsqu'on les combine ! Je vais vous montrer quelques démonstrations super simples
              utilisant ces deux éléments, qui, je l'espère, susciteront de futurs projets intéressants.
            </p><hr>
            <h2>
              Tout d'abord, les bases
            </h2><hr>
            <p>&nbsp;
              Si vous débutez avec <abbr>HTML</abbr>5, vous n'êtes peut-être pas familier avec ce
              <code>&lt;video&gt;</code> élément et son utilisation. Voici un exemple simple que nous utiliserons dans
              les démonstrations suivantes :
            </p>
            <p></p><div id="pre">
            <h4>
              Code HTML
            </h4>
            <pre class="brush: html;collapse: false">
    &lt;video id="v" controls loop&gt;
      &lt;source src="video.mp4" type="video/mp4"&gt;
      &lt;source src="video.webm" type="video/webm"&gt;
      &lt;source src="video.ogv" type="video/ogg"&gt;
    &lt;/video&gt;
</pre>
            <p></p></div>
            <p>&nbsp;
              L'élement <code>&lt;video&gt;</code> contient deux attributs: <code>controls</code> et
              <code>loop</code>. <code>controls</code> indique au navigateur de donner à la vidéo l'ensemble standard
              de commandes vidéo : lecture/pause, curseur, volume, etc. <code>loop</code> indique au navigateur de
              recommencer la vidéo depuis le début une fois qu'elle se termine.
            </p>
            <p>&nbsp;
              Ensuite, à l'intérieur de l'element <code>&lt;video&gt;</code> , nous avons trois éléments enfants
              <code>&lt;source&gt;</code> chacun pointant vers un encodage différent de la même vidéo. Le navigateur
              essaiera chaque source dans l'ordre et lira la première qu'il comprend.
            </p>
            <p>&nbsp;
              <a href="files/demo/Video_Canvas%20Demo%200.html" target="_blank">Ca donne cela</a>
            </p> <hr>
            <h2>
              Maintenant, un exemple simple
            </h2> <hr>
            <p>&nbsp;
              Maintenant que nous savons comment lire une vidéo, ajoutons-y quelques astuces avec
              <code>&lt;canvas&gt;</code> . Tout d'abord, <a href="files/demo/demo1.html" target="_blank">regardez la
              démo</a>
              <br>
              Maintenant, comment ça marche ? Cela nécessite sûrement quelques centaines de lignes de JavaScript,
              n'est-ce pas ? Si vous avez triché et avez déjà regardé le code source de la page de démonstration, vous
              saurez à quel point c'est simple.
            </p>
            <p>&nbsp;
              Nous commençons avec ce <abbr>HTML</abbr>:
            </p>
            <p></p><div id="pre">
            <h4>
              Code HTML
            </h4>
            <pre class="brush: html;collapse: false">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;
      Video/Canvas Demo 1
    &lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id="c"&gt;
    &lt;/canvas&gt;
    &lt;video id="v" controls loop&gt;
      &lt;source src="video.mp4" type="video/mp4"&gt;
      &lt;source src="video.webm" type="video/webm"&gt;
      &lt;source src="video.ogg" type="video/ogg"&gt;
    &lt;/video&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
            <p></p> </div>
            <p>&nbsp;
              Même code vidéo que précédemment, mais avec un <code>&lt;canvas&gt;</code> ajouté. Un peu vide et inutile
              pour le moment, cependant. Nous le mettrons en œuvre plus tard.
            </p>
            <p>&nbsp;
              Maintenant, associons cela à du <abbr>CSS</abbr> pour bien positionner les choses :
            </p>
            <p></p><div id="pre">
            <h4>
              Code CSS
            </h4>
            <pre class="brush: css;collapse: false">
body {
  background: #212121;
}
#c {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
  height: 100%;
}
#v {
  position: absolute;
  top: 50%;
  left: 50%;
  margin: -180px 0 0 -240px;
}

</pre>
            <p></p></div>
            <p>&nbsp;
              Cela permet de centrer la vidéo sur l'écran et d'étendre la zone de dessin sur toute la largeur et la
              hauteur de la fenêtre du navigateur. Étant donné que la zone de dessin apparaît en premier dans le
              document, elle se trouvera derrière la vidéo, exactement là où nous le souhaitons.
            </p>
            <p>&nbsp;
              Et maintenant, voici la magie !
            </p>
            <p></p><div id="pre">
            <h4>
              Code JS
            </h4>
            <pre class="brush: js;collapse: false">
document.addEventListener('DOMContentLoaded', function()
  {var v = document.getElementById('v');
    var canvas = document.getElementById('c');
    var context = canvas.getContext('2d');
    var cw = Math.floor(canvas.clientWidth / 100);
    var ch = Math.floor(canvas.clientHeight / 100);
    canvas.width = cw; canvas.height = ch;
    v.addEventListener('play',
    function() {draw(this, context, cw, ch);}, false);}, false);
    function draw(v, c, w, h) {if(v.paused || v.ended) return false;
    c.drawImage(v, 0, 0, w, h); setTimeout(draw, 20, v, c, w, h);}
</pre>
            <p></p> </div>
            <p>&nbsp;
              Prenez cela en compte un instant. Respirez profondément et absorbez-le. Si court, si doux, si joli…
            </p>
            <p>&nbsp;
              Maintenant, passons en revue tout cela.
            </p>
            <pre class=
            "nobrush">
<code>var v = document.getElementById('v');
var canvas = document.getElementById('c');
var context = canvas.getContext('2d');
var cw = Math.floor(canvas.clientWidth / 100);
var ch = Math.floor(canvas.clientHeight / 100);
canvas.width = cw; canvas.height = ch;</code></pre>
            <p></p>
            <p>&nbsp;
              Cette partie est simple. Je saisis les éléments vidéo et canvas sur la page, et je saisis le contexte 2D
              du canvas pour pouvoir dessiner dessus. Ensuite, je fais quelques calculs rapides pour déterminer la
              largeur et la hauteur que je souhaite pour la surface de dessin du canvas. L'element
              <code>&lt;canvas&gt;</code> lui-même est déjà étiré à la taille de l'écran via <abbr>CSS</abbr>, donc
              cela fera que chaque pixel de la surface de dessin sera égal à environ 100 × 100 pixels sur l'écran.
            </p>
            <p>&nbsp;
              Ce dernier point peut nécessiter quelques explications si vous débutez avec Canvas. Normalement, la
              taille visuelle et la taille de la surface de dessin d'un <code>&lt;canvas&gt;</code> seront les mêmes.
              Dans ce cas, dessiner une ligne de 50 px de long affichera une ligne de 50 px de long. Mais ce n'est pas
              forcément le cas : vous pouvez définir la taille de la surface de dessin via les propriétés
              <code>width</code> et <code>height</code> sur le <code>&lt;canvas&gt;</code> lui-même, puis modifier la
              taille visuelle du canvas avec <abbr>CSS</abbr>pour qu'elle soit différente. Le navigateur agrandira ou
              réduira automatiquement le dessin de manière appropriée pour que la surface de dessin remplisse la taille
              visuelle. Dans ce cas, je règle la surface de dessin du canvas pour qu'elle soit très petite - sur la
              plupart des écrans, elle mesurera environ 10 px de large et 7 px de haut - puis j'étire la taille
              visuelle avec <abbr>CSS</abbr> pour que chaque pixel dessiné soit agrandi 100 fois par le navigateur.
              C'est ce qui provoque l'effet visuel sympa de la démo.
            </p><hr>
            <pre class=
            "nobrush"><code> v.addEventListener('play', function(){ draw(v,context,cw,ch); },false); </code></pre>
            <p>&nbsp;
              Une autre partie simple. Ici, j'attache du code à l'événement « play » sur l'élément vidéo. Cet événement
              est déclenché chaque fois que l'utilisateur appuie sur le bouton « play » pour commencer à regarder la
              vidéo. Tout ce que je fais, c'est appeler la fonction <code>draw()</code> avec les paramètres appropriés
              : la vidéo elle-même, le contexte de dessin du canevas, ainsi que la largeur et la hauteur du canevas.
            </p><hr>
            <pre class=
            "nobrush"><code>function draw(v,c,w,h) { if(v.paused || v.ended) return false; c.drawImage(v,0,0,w,h); setTimeout(draw,20,v,c,w,h); } </code></pre>
           <p>&nbsp;
              La première ligne arrête simplement la fonction immédiatement si l'utilisateur met en pause ou arrête la
              vidéo, de sorte qu'elle ne consomme pas de ressources CPU lorsque rien ne change. La troisième ligne
              appelle à nouveau la fonction <code>draw()</code>, ce qui permet au navigateur de respirer un peu pour
              faire d'autres choses comme mettre à jour la vidéo elle-même. Je mets un délai de 20 ms, donc nous
              obtiendrons environ 50 images par seconde, ce qui est plus que suffisant.
            </p>
            <p>&nbsp;
              La deuxième ligne est l'endroit où la magie opère : elle dessine l'image actuelle de la vidéo directement
              sur le canevas. Oui, c'est aussi simple que cela en a l'air. Il suffit de passer l'élément vidéo et les
              valeurs x, y, la largeur et la hauteur du rectangle sur le canevas dans lequel vous souhaitez qu'il soit
              dessiné. Dans ce cas, il remplit tout le canevas, mais vous pouvez en faire moins (ou plus !) si vous le
              souhaitez.
            </p>
            <p>&nbsp;
              J'utilise ici une autre astuce. Vous vous souvenez que le canevas est vraiment minuscule ? La vidéo sera
              au moins 20 fois plus grande que le canevas sur la plupart des écrans, alors comment la dessiner sur un
              canevas aussi petit ? La fonction <code>drawImage()</code> s'en charge pour nous : elle met
              automatiquement à l'échelle tout ce que vous lui donnez dans le premier argument afin qu'il remplisse le
              rectangle que vous spécifiez. Cela signifie que nous, les auteurs, n'avons pas à nous soucier de faire la
              moyenne des couleurs des pixels (ou d'extrapoler, si vous dessinez une petite vidéo dans un grand
              rectangle) car le navigateur fait tout pour nous. J'utiliserai davantage cette astuce à l'avenir, alors
              faites attention.
            </p>
            <p>&nbsp;
              Et… c'est tout ! La démo entière est réalisée en 20 lignes de code JavaScript facile à lire, produisant
              instantanément un effet d'arrière-plan astucieux pour toute vidéo que vous souhaitez lire. Vous pouvez
              ajuster de manière simple la taille des « pixels » sur le canevas en ajustant les lignes qui définissent
              les variables <var>cw</var> et <var>ch</var>.
            </p><hr>
            <h2>
              Manipulation directe des pixels vidéo
            </h2><hr><p>&nbsp;
              <strong>Attention !</strong> Les 2 dernières démos de cette page vous ne pouvez pas les exécuter en local
              sur votre ordinateur de bureau. Lancez un serveur Web sur votre ordinateur et affichez la page à partir
              de l'hôte local, ou téléchargez-la sur un serveur que vous contrôlez.
            </p>
            <p>&nbsp;
              La dernière démo était sympa, mais elle laissait le navigateur faire tout le travail. Le navigateur a
              réduit la vidéo, l'a dessinée sur le canvas, puis a agrandi les pixels de le canvas, le tout
              automatiquement. Essayons de faire nous-mêmes une partie de cela ! <a href=
              "files/demo/Video_Canvas%20Demo%202.html" target="_blank">Regardez la démo</a> pour voir cela en action,
              où je convertis la vidéo en niveaux de gris à la volée.
            </p>
            <p>&nbsp;
              Le code HTML de la page est identique :
            </p>
            <pre class=
            "nobrush"><code>&lt;video id="v" controls loop&gt;<br>&nbsp; &lt;source src="video.mp4" type="video/mp4"&gt; <br>&nbsp; &lt;source src="video.webm" type="video/webm"&gt; <br>&nbsp; &lt;source src="video.ogg" type="video/ogg"&gt; <br>&lt;/video&gt;<br>&nbsp; &lt;canvas id="c"&gt;<br>&nbsp; &lt;/canvas&gt; </code></pre>
            <p>&nbsp;
              Rien de nouveau ici, passons donc au script.
            </p>
            <p>&nbsp;</p><div id="pre">
            <h4>
              Code JS
            </h4>
            <pre class="brush: js;collapse: false">
document.addEventListener('DOMContentLoaded', function(){
    var v = document.getElementById('v');
    var canvas = document.getElementById('c');
    var context = canvas.getContext('2d');
    var back = document.createElement('canvas');
    var backcontext = back.getContext('2d');

    var cw,ch;

    v.addEventListener('play', function(){
    cw = v.clientWidth;
    ch = v.clientHeight;
    canvas.width = cw;
    canvas.height = ch;
    back.width = cw;
    back.height = ch;
    draw(v,context,backcontext,cw,ch);
    },false);

    },false);

    document.a function draw(v,c,bc,cw,ch) {
    if(v.paused || v.ended) return false;
   /* Tout d'abord, dessine dans le support canvas */
    bc.drawImage(v,0,0,cw,ch);
    /*Récupére les données de pixels à partir du support canvas */
    var idata = bc.getImageData(0,0,cw,ch);
    var data = idata.data;
    var w = idata.width;
    var limit = data.length
   /*Parcoure les sous-pixels en convolutant chacun d'eux à l'aide d'une matrice de détection des contours.*/
    for(var i = 0; i &lt; limit; i++) {
        if( i%4 == 3 ) continue;
        data[i] = 127 + 2*data[i] - data[i + 4] - data[i + w*4];
    }
   /*Dessine les pixels sur le canvas visible */
    c.putImageData(idata,0,0);
    /* Start over!*/
    setTimeout(draw,20,v,c,bc,cw,ch);
    }
</pre>  </div>
            <p></p>
            <p>&nbsp;
              Le script est un peu plus long cette fois-ci. Mais il reste très
              simple !
            </p>
            <p></p><hr>
            <p>&nbsp;
              C'est presque la même chose que ce que j'avais avant, avec deux différences réelles.
            </p> <pre class=
            "nobrush">
<code>document.addEventListener('DOMContentLoaded', function(){
    var v = document.getElementById('v');
    var canvas = document.getElementById('c');
    var context = canvas.getContext('2d');
    var back = document.createElement('canvas');
    var backcontext = back.getContext('2d');

    var cw,ch;

    v.addEventListener('play', function(){
    cw = v.clientWidth;
    ch = v.clientHeight;
    canvas.width = cw;
    canvas.height = ch;
    back.width = cw;
    back.height = ch;
    draw(v,context,backcontext,cw,ch);
    },false);

    },false); </code></pre><p></p>
            <p>&nbsp;
              Tout d'abord, je crée un deuxième canevas et j'en extrait également le contexte. Il s'agit d'un « canevas
              de support », que j'utiliserai pour effectuer des opérations intermédiaires avant de peindre le résultat
              final dans le canevas visible dans le balisage. Le canevas de support n'a même pas besoin d'être ajouté
              au document. Il peut simplement rester ici dans mon script. Cette stratégie est assez utile en général, alors prenez-en note.
            </p>
            <p>&nbsp;
              Deuxièmement, j'attends de redimensionner les toiles jusqu'à ce que la vidéo soit lue, plutôt que de
              simplement les dimensionner immédiatement. En effet, l'élément <code>&lt;video&gt;</code> n'a
              probablement pas chargé sa vidéo lorsque l'événement <code>DOMContentLoaded</code> se déclenche, il
              utilise donc toujours la taille par défaut de l'élément. Cependant, au moment où il est prêt à être lu,
              il connaît la taille de la vidéo et s'est dimensionné de manière appropriée. À ce stade, nous pouvons
              configurer les canvas pour qu'elles aient la même taille que la vidéo.
            </p><hr>
            <pre class=
            "nobrush"><code>function draw(v,c,bc,w,h) { if(v.paused || v.ended) return false; bc.drawImage(v,0,0,w,h); </code></pre>
            <p>&nbsp;
              Comme pour la première démo, la fonction <code>draw()</code> commence par vérifier si elle doit
              s'arrêter, puis dessine simplement la vidéo sur un canevas. Notez que je la dessine sur le canevas de
              support , qui, encore une fois, se trouve simplement dans mon script et n'est pas affiché dans le
              document. Le canevas visible est réservé à l'affichage de la version en niveaux de gris, j'utilise donc
              le canevas de support pour charger les données vidéo initiales.
            </p><hr>
            <pre class="nobrush"><code> var idata = bc.getImageData(0,0,w,h); var data = idata.data; </code></pre>
            <p>&nbsp;
              Voici la première nouveauté. Vous pouvez dessiner quelque chose sur un canevas avec les fonctions de
              dessin de canevas normales ou <code>drawImage()</code>, ou vous pouvez simplement manipuler les pixels
              directement via l'objet ImageData. <code>getImageData()</code> renvoie les pixels d'un rectangle du
              canevas. Dans ce cas, je récupère simplement le tout.
            </p><hr>
            <pre class=
            "nobrush"><code> for(var i = 0; i &lt; data.length; i+=4) { var r = data[i]; var g = data[i+1]; var b = data[i+2]; </code></pre>
            <p>&nbsp;
              Maintenant, une note rapide sur l'objet <code>ImageData</code>. Il renvoie les pixels d'une manière
              spéciale afin de les rendre faciles à manipuler. Si vous avez, par exemple, un canevas de 100 × 100
              pixels, il contient un total de 10 000 pixels. Le tableau ImageData correspondant comportera alors 40 000
              éléments, car les pixels sont répartis par composant et répertoriés de manière séquentielle. Chaque
              groupe de quatre éléments du tableau ImageData représente les canaux rouge, vert, bleu et alpha de ce
              pixel. Pour parcourir les pixels, il suffit d'incrémenter votre compteur de 4 à chaque fois, comme je le
              fais ici. Chaque canal est donc un entier compris entre 0 et 255.
            </p><hr>
            <pre class=
            "nobrush"><code> var brightness = (3*r+4*g+b)&gt;&gt;&gt;3; data[i] = brightness; data[i+1] = brightness; data[i+2] = brightness; </code></pre>
            <p>&nbsp;
              Ici, un petit calcul rapide convertit la valeur RVB du pixel en une seule valeur de « luminosité ». Il
              s'avère que nos yeux réagissent plus fortement à la lumière verte, un peu moins au rouge et beaucoup
              moins au bleu. Je pondère donc les canaux de manière appropriée avant de prendre la moyenne. Ensuite,
              nous renvoyons simplement cette valeur unique aux trois canaux. Comme nous le savons probablement tous,
              lorsque les valeurs rouge, verte et bleue d'une couleur sont égales, vous obtenez du gris. (Pendant tout
              ce processus, j'ignore complètement le quatrième membre de chaque groupe, le canal alpha, car il sera
              toujours de 255.)
            </p><hr>
            <pre class="nobrush"><code> idata.data = data; </code></pre>
            <p>&nbsp;
              Réintroduisez le tableau de pixels modifié dans l'objet ImageData…
            </p>
            <pre class="nobrush"><code> c.putImageData(idata,0,0); </code></pre>
            <p>&nbsp;
              … et ensuite, nous avons placé le tout dans la zone de dessin visible ! Nous n'avons pas eu besoin de
              faire de dessin compliqué ! Il suffit de saisir les pixels, de les manipuler et de les replacer. C'est si
              facile !
            </p>
            <p>&nbsp;
              Une dernière remarque : la manipulation des pixels de la vidéo complète en temps réel est l'un de ces
              rares endroits où les micro-optimisations comptent réellement. Vous pouvez voir leurs effets dans mon
              code ici. À l'origine, je n'ai pas extrait les données de pixels de l'objet ImageData, et j'ai simplement
              écrit « <code>var r = idata.data[i];</code> » et ainsi de suite à chaque fois, ce qui signifiait
              plusieurs recherches de propriétés supplémentaires à chaque itération de la boucle. À l'origine, j'ai
              également simplement divisé la luminosité par 8 et j'ai réduit la valeur au minimum, ce qui est
              légèrement plus lent que le décalage de bits de 3 positions. Dans le code normal, ce genre de choses est
              complètement insignifiant, mais lorsque vous les faites plusieurs millions de fois par seconde (la vidéo
              est de 480 × 360 et contient donc près de 200 000 pixels, chacun étant traité individuellement environ
              100 fois par seconde), ces minuscules retards s'additionnent pour former un décalage notable.
            </p> <hr>
            <h2>
              Manipulation de pixels plus avancée
            </h2> <hr>
            <p>&nbsp;
              Vous pouvez également travailler sur plusieurs pixels à la fois, en composant des effets visuels assez
              complexes. Comme je l'ai indiqué à la fin de la section précédente, les performances comptent beaucoup
              ici, mais vous seriez surpris de ce que vous pouvez obtenir avec un peu de créativité. <a href=
              "files/demo/Video_Canvas%20Demo%204.html" target="_blank">Comme vous pouvez le voir dans la démo</a> , je
              vais créer un effet de relief dans cet exemple, ce qui nécessite que vous utilisiez plusieurs pixels
              d'entrée ensemble pour calculer la valeur de chaque pixel de sortie.
            </p>
            <p>&nbsp;
              Voici le code. Le code HTML et la plupart du code initial sont identiques à l'exemple précédent, j'ai
              donc tout omis sauf la fonction <code>draw()</code>:
            </p>
            <p></p><div id="pre">
            <h4>
              Code JS
            </h4>
            <pre class="brush: js;collapse: false">
document.a function draw(v,c,bc,cw,ch) {
    if(v.paused || v.ended) return false;
    /* Tout d'abord, dessine dans le support canvas */
    bc.drawImage(v,0,0,cw,ch);
    /*Récupére les données de pixels à partir du support canvas */
    var idata = bc.getImageData(0,0,cw,ch);
    var data = idata.data;
    var w = idata.width;
    var limit = data.length
    /* Parcoure les sous-pixels en convolutant chacun d'eux à l'aide d'une matrice de détection des contours. */
    for(var i = 0; i &lt; limit; i++) {
        if( i%4 == 3 ) continue;
        data[i] = 127 + 2*data[i] - data[i + 4] - data[i + w*4];
    }
    /* Dessinez les pixels sur le canvas visible */
    c.putImageData(idata,0,0);
    /* Start over! */
    setTimeout(draw,20,v,c,bc,cw,ch);
    }

</pre>
            <p></p> </div>
            <p>&nbsp;
              Passons maintenant en revue tout cela.
            </p>
            <pre class=
            "nobrush"><code>function draw(v,c,bc,cw,ch) { if(v.paused || v.ended) return false;
            /*Tout d'abord, dessine dans le support canvas */
            bc.drawImage(v,0,0,cw,ch);
            /*Récupére les données de pixels à partir du support canvas*/
            var idata = bc.getImageData(0,0,cw,ch); var data = idata.data; </code></pre>
            <p>&nbsp;
              Même chose que dans le dernier exemple. Vérifiez si nous devons nous arrêter, puis dessinez la vidéo sur
              le canvas de support et récupérez les données de pixels.
            </p>
            <pre class="nobrush"><code>var w = idata.width; </code></pre>
            <p>&nbsp;
              La signification de cette ligne nécessite quelques explications. Je passe déjà la largeur du canevas dans
              la fonction (en tant que variable cw ), alors pourquoi est-ce que je mesure à nouveau sa largeur ici ? En
              fait, je vous mentais plus tôt lorsque je vous expliquais quelle sera la taille du tableau de pixels. Le
              navigateur peut avoir un pixel de canevas correspondant à un pixel d'ImageData, mais les navigateurs sont
              autorisés à utiliser des résolutions plus élevées dans les données d'image, représentant chaque pixel du
              canevas comme un bloc de 2 × 2 pixels d'ImageData, ou peut-être 3 × 3, ou peut-être même plus !
            </p>
            <p>&nbsp;
              Si l'on utilise un « magasin de sauvegarde haute résolution », comme on l'appelle, cela signifie un
              meilleur affichage, car les artefacts d'aliasing (bords irréguliers sur les lignes diagonales) deviennent
              beaucoup plus petits et moins visibles. Cela signifie également qu'au lieu d'un canevas de 100 × 100
              pixels vous donnant un objet ImageData.data avec 40 000 nombres, il pourrait en avoir 160 000 à la place.
              En demandant à ImageData sa largeur et sa hauteur, nous nous assurons que nous parcourons correctement
              les données de pixels, que le navigateur utilise un magasin de sauvegarde basse ou haute résolution pour
              celui-ci.
            </p>
            <p>&nbsp;
              Il est très important que vous l'utilisiez correctement chaque fois que vous avez besoin de la largeur ou
              de la hauteur des données que vous avez extraites en tant qu'objet ImageData. Si trop de gens se trompent
              et utilisent simplement la largeur et la hauteur du canevas à la place, les navigateurs seront alors
              obligés d'utiliser toujours un stockage de sauvegarde basse résolution pour être compatibles avec ces
              scripts défectueux !
            </p>
            <pre class=
            "nobrush"><code> var limit = data.length; for(var i = 0; i &lt; limit; i++) { if( i%4 == 3 ) continue; data[i] = 127 + 2*data[i] - data[i + 4] - data[i + w*4]; } </code></pre>
            <p>&nbsp;
              Je récupère la longueur des données et je la place dans une variable, afin de ne pas avoir à payer pour
              un accès à une propriété à chaque itération de la boucle. (N'oubliez pas que les micro-optimisations sont
              importantes lorsque vous effectuez une manipulation vidéo en temps réel !) Ensuite, je fais une boucle
              sur les pixels, comme je l'ai fait auparavant. Si le pixel se trouve être pour le canal alpha (tous les
              quatre nombres du tableau), je peux simplement l'ignorer - je ne veux pas modifier la transparence.
              Sinon, je fais un peu de calcul pour trouver la différence entre le canal de couleur du pixel actuel et
              les canaux similaires des pixels en dessous et à droite, puis je combine simplement cette différence avec
              la valeur de gris « moyenne » de 127. Cela a pour effet de rendre les zones où les pixels sont de la même
              couleur d'un gris moyen plat, mais les bords où la couleur change soudainement deviendront soit clairs,
              soit sombres.
            </p>
            <p>&nbsp;
              Il y a une autre optimisation ici. Comme je compare uniquement le pixel actuel avec les pixels « plus
              loin » dans les données que je n'ai pas encore examinés, je peux simplement stocker la valeur modifiée
              directement dans les données d'origine, car rien ne regardera plus jamais les données du pixel actuel
              après ce point. Cela signifie que je n'ai pas besoin d'allouer un grand tableau pour contenir les
              résultats avant de le transformer à nouveau en objet ImageData.
            </p>
            <pre class="nobrush"><code> c.putImageData(idata,0,0); setTimeout(draw,20,v,c,bc,cw,ch); </code></pre>
            <p>&nbsp;
              Enfin, dessinez l'objet ImageData modifié dans le canevas visible et configurez un autre appel à la
              fonction dans 20 millisecondes. C'est le même que l'exemple précédent.
            </p><hr>
            <h2>
              Edit
            </h2> <hr>
            <p>&nbsp;
              Nous avons donc exploré aujourd'hui les bases de la combinaison des éléments <code>&lt;video&gt;</code>
              et <code>&lt;canvas&gt;</code> en HTML 5. Les démonstrations étaient très basiques, mais elles ont
              illustré toutes les techniques essentielles dont vous aurez besoin pour réaliser quelque chose d'encore
              plus cool par vous-même .
            </p>
          </div>  </div>
      </div>
      <div class="item3">
       </div>
    </div>
     <script>
      SyntaxHighlighter.config.clipboardSwf = 'files/Scripts/clipboard.swf';
      SyntaxHighlighter.config.stripBrs = true;
      SyntaxHighlighter.all();
    </script>
    </body>
</html>
