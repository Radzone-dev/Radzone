<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>
      video + canvas = magic | HTML5 Doctor
    </title>
    <link rel="stylesheet" href="../wp-content/themes/html5doctor2/style.css" media="screen"><!--[if IE]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="post-template-default single single-post postid-2554 single-format-standard" id="com-html5doctor">
    <header role="banner">
      <div class="inner group">

        <div>
          <div class="logo">
            <h1>
              HTML5 Doctor
            </h1>
            <h2>
              Helping you implement HTML5 today
            </h2>
          </div><!-- end logo -->
        </div></a> <!-- wrapper div for Firefox 3.x ref: http://01i.jp/html5bll -->
         <!-- end #top-nav -->
         <!-- end nav -->
      </div><!-- end .inner -->
    </header><!-- end header -->
    <main id="content" class="group" role="main">
      <div class="main">
        <article class="post group">
          <header class=
          "post-2554 post type-post status-publish format-standard hentry category-elements category-javascript-apis tag-api tag-canvas tag-html-5 tag-html5 tag-video"
          id="post-2554">
            <h1>
              video + canvas = magic
            </h1>
          </header><!-- end header -->
          <div class="entry">
            <p>
              You&#8217;ve already learned about the <code>&lt;video&gt;</code> and <code>&lt;canvas&gt;</code> elements,
              but did you know that they were designed to be used together? In fact, the two elements are absolutely
              wondrous when you combine them! I&#8217;m going to show off a few super-simple demos using these two
              elements, which I hope will prompt cool future projects from you fellow web authors.
            </p>
            <h2>
              First, the basics
            </h2>
            <p>
              If you&#8217;re just starting with <abbr>HTML</abbr>5, you may not be familiar with the
              <code>&lt;video&gt;</code> element and how to use it. Here&#8217;s a simple example that we&#8217;ll be
              using in the later demos:
            </p>
            <pre><code>&lt;video controls loop&gt; &lt;source src=video.webm type=video/webm&gt; &lt;source src=video.ogg type=video/ogg&gt; &lt;source src=video.mp4 type=video/mp4&gt; &lt;/video&gt; </code></pre>
            <p>
              The <code>&lt;video&gt;</code> element contains two attributes: <code>@controls</code> and
              <code>@loop</code>. <code>@controls</code> tells the browser to give the video the standard set of video
              controls: play/pause, scrubber, volume, etc. <code>@loop</code> tells the browser to start the video over
              again from the beginning once it ends.
            </p>
            <p>
              Then, inside the <code>&lt;video&gt;</code> element, we have three child <code>&lt;source&gt;</code>
              elements, each pointing to a different encoding of the same video. The browser will try each source in
              order and play the first one that it understands.
            </p>
            <p>
              <a href="../Video_Canvas Demo 0.html">See this code in action</a>, playing
              the intro to one of the greatest cartoon series of all time.
            </p>
            <figure>
              <img decoding="async" src="../wp-content/uploads/2010/10/video_canvas_fig1.jpg" alt="">
              <figcaption>
                HTML5 Video playing in Chrome
              </figcaption>
            </figure>
            <p>
              (A note about fallback: all of these demos assume that your browser has <code>&lt;video&gt;</code>
              support, which isn&#8217;t true in <abbr>IE</abbr>8 or earlier. Normally, it&#8217;s good practice to
              specify a Flash fallback or similar for those browsers, but that wouldn&#8217;t accomplish much here -
              all of the techniques I demonstrate rely on basic integration between the <code>&lt;video&gt;</code>
              element and the <code>&lt;canvas&gt;</code> element, which you can&#8217;t achieve with a Flash player.
              So I&#8217;ve omitted any non-<code>&lt;video&gt;</code> fallback content in these examples. I&#8217;ve
              still provided multiple sources, though, so all current browsers that do support
              <code>&lt;video&gt;</code> will be able to play it.)
            </p>
            <h2>
              Now, a simple example
            </h2>
            <p>
              Now that we know how to play a video, let&#8217;s mix in some <code>&lt;canvas&gt;</code> shenanigans.
              First, <a href="../demo1.html">check out the demo</a>, then
              come back here for a code walkthrough. I&#8217;ll wait.
            </p>
            <p>
              &hellip;
            </p>
            <figure>
              <img decoding="async" src="../wp-content/uploads/2010/10/video_canvas_fig2.jpg" alt="">
              <figcaption>
                Drawing video onto the canvas at full screen
              </figcaption>
            </figure>
            <p>
              Done? Cool! Now, how does this work? Surely it requires a few hundred lines of JavaScript, right? If
              you&#8217;ve cheated and already looked at the source code of the demo page, you&#8217;ll know how easy
              it is.
            </p>
            <p>
              We start with this <abbr>HTML</abbr>:
            </p>
            <pre><code>&lt;!DOCTYPE html&gt; &lt;title&gt;Video/Canvas Demo 1&lt;/title&gt; &lt;canvas id=c&gt;&lt;/canvas&gt; &lt;video id=v controls loop&gt; &lt;source src=video.webm type=video/webm&gt; &lt;source src=video.ogg type=video/ogg&gt; &lt;source src=video.mp4 type=video/mp4&gt; &lt;/video&gt; </code></pre>
            <p>
              Same video code as before, but now with a <code>&lt;canvas&gt;</code> element thrown into the mix. Kinda
              empty and useless at the moment, though. We&#8217;ll script it into action later.
            </p>
            <p>
              Now, let&#8217;s pair that with some <abbr>CSS</abbr> to get things positioned right:
            </p>
            <pre><code>&lt;style&gt; body { background: black; } #c { position: absolute; top: 0; bottom: 0; left: 0; right: 0; width: 100%; height: 100%; } #v { position: absolute; top: 50%; left: 50%; margin: -180px 0 0 -240px; } &lt;/style&gt; </code></pre>
            <p>
              This just centers the video in the screen and stretches the canvas to the full width and height of the
              browser window. Since the canvas comes first in the document, it&#8217;ll be behind the video, exactly
              where we want it.
            </p>
            <p>
              Now, here comes the magic!
            </p>
            <pre><code>&lt;script&gt; document.addEventListener('DOMContentLoaded', function(){ var v = document.getElementById('v'); var canvas = document.getElementById('c'); var context = canvas.getContext('2d'); var cw = Math.floor(canvas.clientWidth / 100); var ch = Math.floor(canvas.clientHeight / 100); canvas.width = cw; canvas.height = ch; v.addEventListener('play', function(){ draw(this,context,cw,ch); },false); },false); function draw(v,c,w,h) { if(v.paused || v.ended) return false; c.drawImage(v,0,0,w,h); setTimeout(draw,20,v,c,w,h); } &lt;/script&gt; </code></pre>
            <p>
              Take that in for a moment. Just breathe deeply and absorb it. So short, so sweet, so pretty&hellip;
            </p>
            <p>
              Now, let&#8217;s step through it.
            </p>
            <pre><code> var v = document.getElementById('v'); var canvas = document.getElementById('c'); var context = canvas.getContext('2d'); var cw = Math.floor(canvas.clientWidth / 100); var ch = Math.floor(canvas.clientHeight / 100); canvas.width = cw; canvas.height = ch; </code></pre>
            <p>
              This part is simple. I grab hold of the video and canvas elements on the page, and I grab the
              canvas&#8217;s 2D-context so I can draw on it. Then I do some quick calculating to find out how wide and
              tall I want the canvas&#8217;s drawing surface to be. The <code>&lt;canvas&gt;</code> element itself is
              already stretched to the size of the screen via <abbr>CSS</abbr>, so this&#8217;ll make each pixel of the
              drawing surface equal to about 100&#215;100 pixels on the screen.
            </p>
            <p>
              That last bit may need some explanation if you&#8217;re new to canvas. Normally, the visual size and the
              drawing-surface size of a <code>&lt;canvas&gt;</code> element will be the same. In that case, drawing a
              line 50px long will display a line 50px long. But that doesn&#8217;t have to be true - you can set the
              drawing surface&#8217;s size through the <code>@width</code> and <code>@height</code> properties on the
              <code>&lt;canvas&gt;</code> element itself, and then change the visual size of the canvas with
              <abbr>CSS</abbr> to be something different. The browser will then automatically upscale or downscale the
              drawing appropriately to make the drawing surface fill the visual size. In this case, I&#8217;m setting
              the drawing surface of the canvas to be very small - on most screens, it&#8217;ll be about 10px wide and
              7px tall - and then stretching the visual size with <abbr>CSS</abbr> so that each pixel I draw gets blown
              up 100-fold by the browser. That&#8217;s what causes the cool visual effect in the demo.
            </p>
            <pre><code> v.addEventListener('play', function(){ draw(v,context,cw,ch); },false); </code></pre>
            <p>
              Another simple part. Here I attach some code to the &#8220;play&#8221; event on the video element. This
              event gets fired whenever the user hits the &#8220;play&#8221; button to start watching the video. All I
              do is call the <code>draw()</code> function with the appropriate parameters: the video itself, the
              canvas&#8217;s drawing context, and the canvas&#8217;s width and height.
            </p>
            <pre><code>function draw(v,c,w,h) { if(v.paused || v.ended) return false; c.drawImage(v,0,0,w,h); setTimeout(draw,20,v,c,w,h); } </code></pre>
            <p>
              The first line just makes the function stop immediately if the user pauses or stops the video, so
              it&#8217;s not burning <abbr>CPU</abbr> when nothing&#8217;s changing. The third line calls the
              <code>draw()</code> function again, allowing the browser a little breathing space to do other things like
              update the video itself. I&#8217;m putting in a 20ms delay, so we&#8217;ll get roughly 50fps, which is
              more than enough.
            </p>
            <p>
              The second line is where the magic happens - it draws the current frame of the video directly onto the
              canvas. Yes, it&#8217;s exactly as simple as it looks. Just pass the video element and the x, y, width,
              and height of the rectangle on the canvas you want it to draw into. In this case, it&#8217;s filling up
              the entire canvas, but you could do less (or more!) if you wanted.
            </p>
            <p>
              I&#8217;m using another trick here. Remember how the canvas is really tiny? The video will be at least 20
              times bigger than the canvas on most screens, so how do we draw it onto such a tiny canvas? The
              <code>drawImage()</code> function handles that for us - it automatically scales whatever you hand it in
              the first argument so that it fills the rectangle you specify. That means we authors don&#8217;t have to
              worry about averaging the pixel colors (or extrapolating, if you&#8217;re drawing a small video into a
              big rectangle) because the browser does it all for us. I&#8217;ll use this trick more in the future, so
              watch out for it.
            </p>
            <p>
              And&hellip;that&#8217;s it! The entire demo is done in 20 lines of easy-to-read JavaScript code,
              instantly producing a nifty background effect for any video you wish to play. You can trivially adjust
              the size of the &#8220;pixels&#8221; on the canvas by adjusting the lines that set the <var>cw</var> and
              <var>ch</var> variables.
            </p>
            <h2>
              Directly manipulating video pixels
            </h2>
            <p>
              The last demo was cool, but it just let the browser do all the heavy lifting. The browser downscaled the
              video, drew it onto the canvas, and then upscaled the canvas pixels, all automatically. Let&#8217;s try
              our hand at doing some of this ourselves! <a href=
              "../Video_Canvas Demo 2.html">Check out the demo</a> to see this in
              action, where I convert the video to grayscale on the fly.
            </p>
            <figure>
              <img decoding="async" src="../wp-content/uploads/2010/10/video_canvas_fig3.jpg" alt="">
              <figcaption>
                Video made greyscale with canvas manipulation
              </figcaption>
            </figure>
            <p>
              The HTML for the page is basically identical:
            </p>
            <pre><code>&lt;video id=v controls loop&gt; &lt;source src=video.webm type=video/webm&gt; &lt;source src=video.ogg type=video/ogg&gt; &lt;source src=video.mp4 type=video/mp4&gt; &lt;/video&gt; &lt;canvas id=c&gt;&lt;/canvas&gt; </code></pre>
            <p>
              Nothing new here, so let&#8217;s move onto the script.
            </p>
            <pre><code>document.addEventListener('DOMContentLoaded', function(){ var v = document.getElementById('v'); var canvas = document.getElementById('c'); var context = canvas.getContext('2d'); var back = document.createElement('canvas'); var backcontext = back.getContext('2d'); var cw,ch; v.addEventListener('play', function(){ cw = v.clientWidth; ch = v.clientHeight; canvas.width = cw; canvas.height = ch; back.width = cw; back.height = ch; draw(v,context,backcontext,cw,ch); },false); },false); function draw(v,c,bc,w,h) { if(v.paused || v.ended) return false; // First, draw it into the backing canvas bc.drawImage(v,0,0,w,h); // Grab the pixel data from the backing canvas var idata = bc.getImageData(0,0,w,h); var data = idata.data; // Loop through the pixels, turning them grayscale for(var i = 0; i &lt; data.length; i+=4) { var r = data[i]; var g = data[i+1]; var b = data[i+2]; var brightness = (3*r+4*g+b)&gt;&gt;&gt;3; data[i] = brightness; data[i+1] = brightness; data[i+2] = brightness; } idata.data = data; // Draw the pixels onto the visible canvas c.putImageData(idata,0,0); // Start over! setTimeout(function(){ draw(v,c,bc,w,h); }, 0); } </code></pre>
            <p>
              The script is a bit longer this time, because we&#8217;re actually doing some work. But it&#8217;s still
              really simple!
            </p>
            <pre><code>document.addEventListener('DOMContentLoaded', function(){ var v = document.getElementById('v'); var canvas = document.getElementById('c'); var context = canvas.getContext('2d'); var back = document.createElement('canvas'); var backcontext = back.getContext('2d'); var cw,ch; v.addEventListener('play', function(){ cw = v.clientWidth; ch = v.clientHeight; canvas.width = cw; canvas.height = ch; back.width = cw; back.height = ch; draw(v,context,backcontext,cw,ch); },false); </code></pre>
            <p>
              This is almost the same as I had before, with two real differences.
            </p>
            <p>
              First, I&#8217;m creating a second canvas and pulling the context out of it as well. This is a
              &#8220;backing canvas&#8221;, which I&#8217;ll use to perform intermediate operations before painting the
              final result into the visible canvas in the markup. The backing canvas doesn&#8217;t even need to be
              added to the document. It can just hang out here in my script. This strategy will be used a lot in later
              examples, and it&#8217;s quite useful in general, so take note of it.
            </p>
            <p>
              Second, I&#8217;m waiting to resize the canvases until the video is played, rather than just sizing them
              immediately. This is because the <code>&lt;video&gt;</code> element probably hasn&#8217;t loaded its
              video up when the <code>DOMContentLoaded</code> event fires, so it&#8217;s still using the default size
              for the element. By the time it&#8217;s ready to play, though, it knows the size of the video and has
              sized itself appropriately. At that point, we can set up the canvases to be the same size as the video.
            </p>
            <pre><code>function draw(v,c,bc,w,h) { if(v.paused || v.ended) return false; bc.drawImage(v,0,0,w,h); </code></pre>
            <p>
              Same as the first demo, the <code>draw()</code> function begins by checking if it should stop, then just
              draws the video onto a canvas. Note that I&#8217;m drawing it onto the <em>backing</em> canvas, which,
              again, is just sitting in my script and isn&#8217;t displayed in the document. The visible canvas is
              reserved for the displaying the grayscale version, so I use the backing canvas to load up the initial
              video data.
            </p>
            <pre><code> var idata = bc.getImageData(0,0,w,h); var data = idata.data; </code></pre>
            <p>
              Here&#8217;s the first new bit. You can draw something onto a canvas with either the normal canvas
              drawing functions or <code>drawImage()</code>, or you can just manipulate the pixels directly through the
              ImageData object. <code>getImageData()</code> returns the pixels from a rectangle of the canvas. In this
              case, I&#8217;m just getting the whole thing.
            </p>
            <p>
              <strong>Warning!</strong> If you&#8217;re following along and trying to run these demos on your desktop,
              this is where you&#8217;ll probably run into trouble. The <code>&lt;canvas&gt;</code> element keeps track
              of where the data inside of it comes from, and if it knows that you got something from another website
              (for example, if the <code>&lt;video&gt;</code> element you painted into the canvas is pointing to a
              cross-origin file), it&#8217;ll &#8220;taint&#8221; the canvas. You&#8217;re not allowed to grab the
              pixel data from a tainted canvas. Unfortunately, <code>file:</code> urls count as
              &#8220;cross-origin&#8221; for this purpose, so you can&#8217;t run this on your desktop. Either fire up
              a web server on your computer and view the page from localhost, or upload it to some other server you
              control.
            </p>
            <pre><code> for(var i = 0; i &lt; data.length; i+=4) { var r = data[i]; var g = data[i+1]; var b = data[i+2]; </code></pre>
            <p>
              Now, a quick note about the ImageData object. It returns the pixels in a special way in order to make
              them easy to manipulate. If you have, say, a 100&#215;100 pixel canvas, it contains a total of 10,000
              pixels. The ImageData array for it will then have 40,000 elements, because the pixels are broken up by
              component and listed sequentially. Each group of four elements in the ImageData array represent the red,
              green, blue, and alpha channels for that pixel. To loop through the pixels, just increment your counter
              by 4 every time, like I do here. Each channel, then, is an integer between 0 and 255.
            </p>
            <pre><code> var brightness = (3*r+4*g+b)&gt;&gt;&gt;3; data[i] = brightness; data[i+1] = brightness; data[i+2] = brightness; </code></pre>
            <p>
              Here, a quick bit of math converts the <abbr>RGB</abbr> value of the pixel into a single
              &#8220;brightness&#8221; value. As it turns out, our eyes respond most strongly to green light, slightly
              less so to red, and much less so to blue. So, I weight the channels appropriately before taking the
              average. Then, we just feed that single value back to all three channels. As we probably all know, when
              the red, green, and blue values of a color are equal, you get gray. (During this whole process, I&#8217;m
              completely ignoring the fourth member of each group, the alpha channel, because it&#8217;s always going
              to be 255.)
            </p>
            <pre><code> idata.data = data; </code></pre>
            <p>
              Shove the modified pixel array back into the ImageData object&hellip;
            </p>
            <pre><code> c.putImageData(idata,0,0); </code></pre>
            <p>
              &hellip;and then shove the whole thing into the visible canvas! We didn&#8217;t need to do any
              complicated drawing at all! Just grab the pixels, manipulate them, and shove them back in. So easy!
            </p>
            <p>
              A final note: real-time full-video pixel manipulation is one of those rare places where
              micro-optimizations actually matter. You can see their effects in my code here. Originally, I
              didn&#8217;t pull the pixel data out of the ImageData object, and just wrote &#8220;var r =
              idata.data[i];&#8221; and so on each time, which meant several extra property lookups in every iteration
              of the loop. I also originally just divided the brightness by 8 and floored the value, which is slightly
              slower than bit-shifting by 3 places. In normal code, these sorts of things are <em>completely</em>
              insignificant, but when you&#8217;re doing them several million times per second (the video is
              480&#215;360, and thus contains nearly 200,000 pixels, each of which is individually handled roughly 100
              times a second), those tiny delays add up into a noticeable lag.
            </p>
            <h2>
              More advanced pixel manipulation
            </h2>
            <p>
              You can operate on more than just a single pixel at a time, too, composing some fairly complex visual
              effects. As I noted at the end of the previous section, performance matters a lot here, but you&#8217;d
              be surprised what you can squeeze out with a little creativity. <a href=
              "../Video_Canvas Demo 4.html">As you can see in the demo</a>, I&#8217;ll
              be creating an emboss effect in this example, which requires you to use several input pixels together to
              compute the value of each output pixel.
            </p>
            <figure>
              <img decoding="async" src="../wp-content/uploads/2010/10/video_canvas_fig4.jpg" alt="">
              <figcaption>
                Embossed video with canvas manipulation
              </figcaption>
            </figure>
            <p>
              Here&#8217;s the code. The <abbr>HTML</abbr> and most of the beginning code is identical to the previous
              example, so I&#8217;ve omitted everything but the <code>draw()</code> function:
            </p>
            <pre><code>function draw(v,c,bc,cw,ch) { if(v.paused || v.ended) return false; // First, draw it into the backing canvas bc.drawImage(v,0,0,cw,ch); // Grab the pixel data from the backing canvas var idata = bc.getImageData(0,0,cw,ch); var data = idata.data; var w = idata.width; var limit = data.length // Loop through the subpixels, convoluting each using an edge-detection matrix. for(var i = 0; i &lt; limit; i++) { if( i%4 == 3 ) continue; data[i] = 127 + 2*data[i] - data[i + 4] - data[i + w*4]; } // Draw the pixels onto the visible canvas c.putImageData(idata,0,0); // Start over! setTimeout(draw,20,v,c,bc,cw,ch); } </code></pre>
            <p>
              Now let&#8217;s step through that.
            </p>
            <pre><code>function draw(v,c,bc,cw,ch) { if(v.paused || v.ended) return false; // First, draw it into the backing canvas bc.drawImage(v,0,0,cw,ch); // Grab the pixel data from the backing canvas var idata = bc.getImageData(0,0,cw,ch); var data = idata.data; </code></pre>
            <p>
              Same as the last example. Check to see if we should stop, then draw the video onto the backing canvas and
              grab the pixel data from it.
            </p>
            <pre><code>var w = idata.width; </code></pre>
            <p>
              The significance of this line needs some explanation. I&#8217;m already passing the canvas&#8217;s width
              into the function (as the <var>cw</var> variable), so why am I re-measuring its width here? Well, I was
              actually lying to you earlier when I explained how large the pixel array will be. The browser
              <em>might</em> have one pixel of canvas map to one pixel of ImageData, but browsers are allowed to use
              higher resolutions in the image data, representing each pixel of canvas as a 2&#215;2 block of ImageData
              pixels, or maybe 3&#215;3, or maybe even greater!
            </p>
            <p>
              If they use a &#8220;high-resolution backing store&#8221;, as this is called, it means better display, as
              aliasing artifacts (jagged edges on diagonal lines) become much smaller and less noticeable. It also
              means that rather than a 100&#215;100 pixel canvas giving you an ImageData.data object with 40,000
              numbers, it might have 160,000 numbers instead. By asking the ImageData for its width and height, we
              ensure that we loop through the pixel data properly no matter whether the browser uses a low-res or
              high-res backing store for it.
            </p>
            <p>
              It&#8217;s very important that you use this properly whenever you need the width or height of the data
              you pulled out as an ImageData object. If too many people screw it up and just use the canvas&#8217;s
              width and height instead, then browsers will be forced to always use a low-res backing store to be
              compatible with those broken scripts!
            </p>
            <pre><code> var limit = data.length; for(var i = 0; i &lt; limit; i++) { if( i%4 == 3 ) continue; data[i] = 127 + 2*data[i] - data[i + 4] - data[i + w*4]; } </code></pre>
            <p>
              I&#8217;m grabbing the data&#8217;s length and stuffing it into a variable, so I don&#8217;t have to pay
              for a property access on every single iteration of the loop. (Remember, micro-optimizations matter when
              you&#8217;re doing real-time video manipulation!) Then I just loop through the pixels, like I did before.
              If the pixel happens to be for the alpha channel (every fourth number in the array), I can just skip it -
              I don&#8217;t want to change the transparency. Otherwise, I&#8217;ll do a little math to find the
              difference between the current pixel&#8217;s color channel and the similar channels of the pixels below
              and to the right, then just combine that difference with the &#8220;average&#8221; gray value of 127.
              This has the effect of making areas where the pixels are the same color a flat medium gray, but edges
              where the color suddenly changes will turn either bright or dark.
            </p>
            <p>
              There&#8217;s another optimization here. Because I&#8217;m only comparing the current pixel with pixels
              &#8220;further ahead&#8221; in the data which I haven&#8217;t looked at yet, I can just store the changed
              value right back in the original data, because nothing will ever look at the current pixel&#8217;s data
              again after this point. This means I don&#8217;t have to allocate a big array to hold the results before
              turning it back into an ImageData object.
            </p>
            <pre><code> c.putImageData(idata,0,0); setTimeout(draw,20,v,c,bc,cw,ch); </code></pre>
            <p>
              Finally, draw the modified ImageData object into the visible canvas, and set up another call to the
              function in 20 milliseconds. This is the same as the previous example.
            </p>
            <h2>
              Wrapping up
            </h2>
            <p>
              So, we&#8217;ve explored the basics of combining <abbr>HTML</abbr>5&#8217;s <code>&lt;canvas&gt;</code>
              and <code>&lt;video&gt;</code> elements today. The demos were very basic, but they illustrated all the
              essential techniques you&#8217;ll need to do something even cooler on your own:
            </p>
            <ol>
              <li>You can draw a video directly onto a canvas.
              </li>
              <li>When you draw onto a canvas, the browser will automatically scale the image for you if necessary.
              </li>
              <li>When you display a canvas, the browser will again scale it automatically if the visible size is
              different from the size of the backing-store.
              </li>
              <li>You can do direct pixel-level manipulation of a canvas by just grabbing the ImageData, changing it,
              and drawing it back in.
              </li>
            </ol>
          </div><!-- end .entry -->
          <!-- end aside -->
          <!-- end #author-bio -->
          <!-- end #comments -->
        </article><!-- end .post -->
      </div><!-- end .main -->
      <!-- end .secondary -->
      <!-- end #sub-footer -->
    </main><!-- end #content -->
    <footer role="contentinfo">
      <div class="inner"></div><!-- end .inner -->
    </footer>
  </body>
</html>
